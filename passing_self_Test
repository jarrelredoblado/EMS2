#define X_PIN A0
#define Y_PIN A1
#define Z_PIN A2
#define ST_PIN 13

const float V_REF = 5000.0; // in mV
const int ADC_RESOLUTION = 1024;
const float SENSITIVITY = 300.0; // mV/g typical

// Expected self-test response (from datasheet)
const float X_TYP_mV = -325.0;
const float Y_TYP_mV = 325.0;
const float Z_TYP_mV = 550.0;

void setup() {
  Serial.begin(9600);
  pinMode(ST_PIN, OUTPUT);
  digitalWrite(ST_PIN, LOW); // Ensure self-test is off
  delay(1000);
  runSelfTest();
}

void loop() {
  // Nothing to do in loop
}

void runSelfTest() {
  // Step 1: Read baseline values
  digitalWrite(ST_PIN, LOW);
  delay(100);
  float xBase = readVoltage(X_PIN);
  float yBase = readVoltage(Y_PIN);
  float zBase = readVoltage(Z_PIN);

  // Step 2: Enable self-test
  digitalWrite(ST_PIN, HIGH);
  delay(100);
  float xST = readVoltage(X_PIN);
  float yST = readVoltage(Y_PIN);
  float zST = readVoltage(Z_PIN);

  // Step 3: Compute differences
  float dx = xST - xBase;
  float dy = yST - yBase;
  float dz = zST - zBase;

  // Step 4: Check validity (Â±50% tolerance from typical)
  bool xPass = checkPass(dx, X_TYP_mV);
  bool yPass = checkPass(dy, Y_TYP_mV);
  bool zPass = checkPass(dz, Z_TYP_mV);

  if (xPass && yPass && zPass) {
    Serial.println("self-test passed");
  }
}

float readVoltage(int pin) {
  int raw = analogRead(pin);
  return (raw * V_REF) / (ADC_RESOLUTION - 1);
}

bool checkPass(float measured, float expected) {
  float min = expected * 0.5;
  float max = expected * 1.5;
  if (expected < 0) {
    return measured <= (expected * 0.5) && measured >= (expected * 1.5);
  }
  return measured >= min && measured <= max;
}
